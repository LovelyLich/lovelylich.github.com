---
layout:     post
title:      "TCP的慢启动、拥塞避免、快速恢复和快速重传--概述"
date:       2019-07-15 12:00:00
author:     "Yi"
header-img: "img/post-bg-2015.jpg"
catalog: true
tags:
    - TCP 协议
---

### 慢启动
TCP 三次握手后，所有新建的连接都需要以极快速度逐步探测可用带宽，尽快达到带宽瓶颈点，但同时又不能直接一次性发太多数据包，避免造成网络拥堵。目前Linux内核所有新建的连接，都会以慢启动来增大拥塞窗口。慢启动算法是：TCP建连成功后，首先直接向对端发送初始拥塞窗口个数的数据包，此后，每收到一个ACK拥塞窗口+1。所以在没有丢包的情况下，经过第一个RTT后，此前发送的所有N个数据包都已经ACK掉，新窗口即为N+N=2N，以此类推。
另外，考虑到目前整体网络带宽已经大幅提高，故Linux 最新内核以10作为初始窗口：

```c
/* TCP initial congestion window as per rfc6928 */
#define TCP_INIT_CWND10
```

所以目前Linux目前的慢启动算法实现是：

开始          --->     cwnd=10
经过1个RTT后   --->     cwnd=2\*10=20
经过2个RTT后   --->     cwnd=2\*20=40
经过3个RTT后   --->     cwnd=2\*40=80
经过N个RTT后   --->     cwnd=(2^N)\*10

假设带宽为W，则经过$\log_2\frac W {10}$个RTT后，到达带宽瓶颈点。

### 拥塞避免
TCP 并不会让慢启动算法无休止持续增长，而是会设定一个慢启动阈值，当cwnd窗口超过这个阈值时，会进入拥塞避免算法阶段。
拥塞避免算法是在当前拥塞窗口cwnd内，对于每个收到的ACK，拥塞窗口增加$\frac{1}{cwnd}$，从而当整个cwnd窗口的数据包都收到ACK时，拥塞窗口变为cwnd+1，也就是相比于慢启动每个RTT拥塞窗口翻倍，在拥塞避免阶段，每个RTT拥塞窗口只增加1，实现缓慢增长逐步试探带宽瓶颈点。
目前Linux 内核的慢启动阈值默认为：

```c
#define TCP_INFINITE_SSTHRESH0x7fffffff
```
